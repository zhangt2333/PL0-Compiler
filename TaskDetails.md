本文分两部分：

*   原封不动の任务描述
*   我的分析与实现



# 任务描述

### PL/0 语言文法的 BNF 表示

```
〈程序〉→〈分程序〉。
〈分程序〉→ [〈常量说明部分〉][〈变量说明部分〉][〈过程说明部分〉]〈语句〉
〈常量说明部分〉 → CONST〈常量定义〉{ ,〈常量定义〉}；
〈常量定义〉 → 〈标识符〉=〈无符号整数〉
〈无符号整数〉 → 〈数字〉{〈数字〉}
〈变量说明部分〉 → VAR〈标识符〉{ ,〈标识符〉}；
〈标识符〉 → 〈字母〉{〈字母〉|〈数字〉}
〈过程说明部分〉 → 〈过程首部〉〈分程序〉；{〈过程说明部分〉}
〈过程首部〉 → procedure〈标识符〉；
〈语句〉 → 〈赋值语句〉|〈条件语句〉|〈当型循环语句〉|〈过程调用语句〉|〈读语句〉|〈写语句〉|〈复合语句〉|〈空〉
〈赋值语句〉 → 〈标识符〉:=〈表达式〉
〈复合语句〉 → begin〈语句〉{ ；〈语句〉}〈end〉
〈条件〉 → 〈表达式〉〈关系运算符〉〈表达式〉|odd〈表达式〉
〈表达式〉 → [+|-]〈项〉{〈加减运算符〉〈项〉}
〈项〉 → 〈因子〉{〈乘除运算符〉〈因子〉}
〈因子〉 → 〈标识符〉|〈无符号整数〉|(〈表达式〉)
〈加减运符〉 → +|-
〈乘除运算符〉 → *|/
〈关系运算符〉 → =|#|<|<=|>|>=
〈条件语句〉 → if〈条件〉then〈语句〉
〈过程调用语句〉 → call〈标识符〉
〈当型循环语句〉 → while〈条件〉do〈语句〉
〈读语句〉 → read(〈标识符〉{ ，〈标识符〉})
〈写语句〉 → write(〈标识符〉{，〈标识符〉})
〈字母〉 → a|b|c…x|y|z
〈数字〉 → 0|1|2…7|8|9
```

### 一、PL/0 语言建立一个词法分程序 GETSYM（函数）

把关键字、算符、界符称为语言固有的单词，标识符、常量称为用户自定义的单词。

为此设置三个全程量：SYM, ID, NUM 

*   SYM：存放每个单词的类别，为内部编码的表示形式。
*   ID：存放用户所定义的标识符的值，即标识符字符串的机内表示。
*   NUM：存放用户定义的数。

GETSYM 要完成的任务：

1.	滤掉单词间的空格。
2.	识别关键字，用查关键字表的方法识别。当单词是关键字时，将对应的类别放在SYM中。如IF的类别为IFSYM，THEN的类别为 THENSYM。
3.	识别标识符，标识符的类别为IDENT，IDENT放在SYM中，标识符本身的值放在ID中。关键字或标识符的最大长度是10。
4.	拼数，将数的类别NUMBER放在SYM中，数本身的值放在NUM中。
5.	拼由两个字符组成的运算符，如：>=、<=等等，识别后将类别存放在SYM中。
6.	打印源程序，边读入字符边打印。（由于一个单词是由一个或多个字符组成的，所以在词法分析程序 GETSYM 中定义一个读字符过程 GETCH）







# 分析与实现

### 一、词法分程序 getSymbol

枚举类的设计：

*   【关键字、算符、界符】是语言固有单词，【标识符、常量】是用户自定义单词
*   设计一个枚举类承载它们，但是 C++ 的枚举类没法像 Java 一样设计多值组和方法。
*   所以设计一个类 SymbolType 用于承载常量，设计一个类 Symbol 来承载具体的 Symbol 及其值

词法分析器类的设计：

*   采用面向对象的思想去设计整个实验，那么可以设计一个类 Lexer，用于做词法分析
*   主要功能是识别 Symbol，成员变量需要一个输入流 istream 的实现类实例
*   要完成的任务是：
    1.  识别 关键字
    2.  识别 标识符
    3.  识别 数
    4.  识别 两个字符构成的 Symbol
    5.  识别 其他 Symbol
    6.  打印源程序，边读入字符边打印


